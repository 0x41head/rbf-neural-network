{
  "name": "RBF",
  "tagline": "Python package containing the tools necessary for radial basis function (RBF) applications",
  "body": "# RBF\r\nPython package containing the tools necessary for radial basis \r\nfunction (RBF) applications.  Applications include \r\ninterpolating/smoothing scattered data and solving PDEs over \r\ncomplicated domains. \r\n\r\n\r\n## Features\r\n* Efficient evaluation of RBFs and their analytically derived spatial \r\nderivatives.  This package allows for unlimited spatial dimensions and \r\narbitrary spatial derivatives. \r\n* Regularized RBF interpolation, which can fit a smoothed interpolant \r\nto noisy data\r\n* Generation of radial basis function finite difference (RBF-FD) \r\nweights, which are used to estimate derivatives of scattered data\r\n* Efficient generation of RBF-FD stencils which can be given \r\nconstraints to not cross a user defined boundary. This is useful if \r\nthe user does not want to estimate a derivative over a known \r\ndiscontinuity.\r\n* computational geometry functions for 1, 2, and 3 spatial dimensions. \r\nAmong these functions is a point in polygon/polyhedra test\r\n* Halton sequence generator\r\n* Node generation with a minimum energy algorithm.  This is used for \r\nsolving PDEs with the spectral RBF method or the RBF-FD method\r\n\r\n\r\n## Table of Contents\r\n1. [Installation](#installation)\r\n2. [Logging](#logging)\r\n3. [Usage](#usage)\r\n  1. [Basis](#basis)\r\n  2. [Interpolation](#interpolation)\r\n  3. [Solving PDEs: Spectral Method](#solving-pdes-spectral-method)\r\n  3. [Solving PDEs: RBF-FD Method](#solving-pdes-rbf-fd-method)\r\n4. [To Do](#to-do)\r\n5. [Acknowledgements](#acknowledgements)\r\n\r\n## Installation\r\nRBF requires the following python packages: numpy, scipy, sympy, \r\nmatplotlib, and cython.  These dependencies should be satisfied with \r\njust the base Anaconda python package \r\n(https://www.continuum.io/downloads)\r\n\r\ndownload the RBF package\r\n```\r\n$ git clone http://github.com/treverhines/RBF.git \r\n```\r\ncompile and install\r\n```\r\n$ cd RBF\r\n$ python setup.py install\r\n```\r\ntest that everything works\r\n```\r\n$ cd test\r\n$ python -m unittest discover\r\n```\r\n\r\n\r\n## Logging\r\nThis package uses loggers for some of the more time intensive \r\nprocesses.  To print the logged content to stdout, start your python \r\nscript with\r\n```python\r\nimport logging\r\nlogging.basicConfig(level=logging.INFO)\r\n```\r\n\r\n\r\n## Usage\r\nThe following is a quick introduction to some of the features of this \r\npackage.  More examples can be found in the `demo` directory.\r\n\r\n### Basis\r\nThe linchpin of this module is the RBF class, which is used to \r\nevaluate an RBF and its derivatives.  An RBF is instantiated using a \r\nsymbolic sympy expression.  Evaluating the RBFs is done by calling the \r\nRBF instance where the user supplies the evaluation points, the RBF \r\ncenters, and the desired derivate (if any).  When called, an \r\nanalytical derivative of the symbolic expression is evaluated and then \r\nthe function is compiled into cython code.  This compiled code is \r\nsaved and reused when the RBF is called again with the same derivative \r\nspecification.\r\n  \r\nHere is an example where an RBF is instantiated and then the RBF and \r\nits first derivative are evaluated. See the help documentation for \r\n`rbf.basis.RBF` for more information on the arguments\r\n```python\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport rbf.basis\r\n\r\nR = rbf.basis.get_R()\r\nexpr = 1/(1 + R**2) # inverse quadratic\r\niq = rbf.basis.RBF(expr)\r\n\r\n# create RBF centers\r\nc = np.array([-2.0,0.0,2.0])[:,None]\r\n# create evaluation points\r\nx = np.linspace(-5.0,5.0,1000)[:,None]\r\n\r\n# evaluate each RBF at x\r\nsoln = iq(x,c)\r\n# evaluate the first derivative of each RBF at x\r\nsoln_diff = iq(x,c,diff=(1,))\r\n```\r\nplotting the results\r\n```python\r\nfig,ax = plt.subplots(figsize=(6,4))\r\nax.plot(x,soln)\r\nax.set_xlim((-5.0,5.0))\r\nax.set_title('inverse quadratic')\r\nax.grid()\r\n\r\nfig,ax = plt.subplots(figsize=(6,4))\r\nax.plot(x,soln_diff)\r\nax.set_xlim((-5.0,5.0))\r\nax.set_title('inverse quadratic first derivative')\r\nax.grid()\r\nplt.show()\r\n```\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/basis/figures/basis_1.png \"basis_1\")\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/basis/figures/basis_2.png \"basis_2\")\r\n\r\nThe user does not need to worry about instantiation of an RBF class \r\nbecause many of the commonly used RBFs are already instantiated and \r\ncan be called using function in the `rbf.basis` module. The available \r\nfunctions are\r\n* ga : gaussian, exp(-(EPS\\*R)^2)\r\n* iq : inverse quadratic, 1/(1+(EPS\\*R^2)\r\n* mq : multiquadratic, sqrt(1 + (EPS\\*R)^2)\r\n* imq : inverse multiquadratic, 1/sqrt(1 + (EPS\\*R)^2)\r\n* phs{1,3,5,7} : odd order polyharmonic splines, (EPS\\*R)^{1,3,5,7}\r\n* phs{2,4,6,8} : even order polyharmonic splines, log(EPS\\*R)(EPS\\*R)^{2,4,6,8}  \r\n\r\nEPS is a scaling factor which can be obtained for defining your own \r\nRBFs by calling `rbf.basis.get_EPS()`. When evaluating the RBF, you \r\ncan set the scaling factor with the `eps` key word argument.  For \r\ninterpolation problems or when trying to solve a PDE, EPS is often \r\ntreated as a free parameter that needs to be optimized. This can \r\nbecome an intractible burden for large problems. When using odd order \r\npolyharmonic splines, which are scale-invariant, the shape parameter \r\ndoes not need to be optimized. Odd order polyharmonic splines \r\ngenerally perform well for interpolation and solving PDEs.\r\n\r\n### Interpolation\r\nRadial basis functions are most commonly used for interpolating \r\nscattered data in multidimensional space, but for simplicity we start \r\nwith a one-dimensional demonstration.  Creating a simple RBF \r\ninterpolant is straight forward with an RBF instance\r\n```python\r\nfrom rbf.basis import phs3\r\n\r\nx = np.linspace(-np.pi,np.pi,5)[:,None] # observation points\r\nu = np.sin(x[:,0]) # values at the observation points\r\nxitp = np.linspace(-4.0,4.0,1000)[:,None] # interpolation points\r\nA = phs3(x,x) # coefficient matrix\r\ncoeff = np.linalg.solve(A,u) # find the coefficients for each RBF\r\n\r\n# Evaluates each of the RBFs at the interpolation points\r\nuitp = phs3(xitp,x).dot(coeff) \r\n```\r\nAlternatively, we can arrive at the same solution with the \r\n`RBFInterpolant` class\r\n```python\r\nfrom rbf.interpolate import RBFInterpolant\r\n\r\nI = RBFInterpolant(x,u,order=-1)\r\nuitp = I(xitp)\r\n```\r\nThe `order` key word argument specifies the order of the polynomial \r\nwhich is added to the interpolant for improved accuracy.  By setting \r\nit to -1, we indicate that we do not want to add any polynomial to our \r\ninterpolant. By default, the RBFInterpolant adds a constant and linear \r\nterm (i.e. order=1). The default RBF used by `RBFInterpolant` is \r\n`phs3`.  Using the default arguments we see that our interpolant is a \r\nbetter prediction of the true signal, sin(x).\r\n```python\r\nI = RBFInterpolant(x,u)\r\nuitp2 = I(xitp)\r\n```\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/interpolate/figures/interp1d.png \"demo_interpolate_1d\")\r\n\r\nIn the next example we fit a smoothed interpolant to 100 noisy samples \r\nof a two-dimensional function. The smoothness is controlled with the \r\n`penalty` argument. To further show off the features of \r\n`RBFInterpolant` we show that we can easily differentiate the smoothed \r\ninterpolant. \r\n```python\r\nx = np.random.random((100,2)) # observation points\r\n\r\n# find the function value at the observation points\r\nu = np.sin(2*np.pi*x[:,0])*np.cos(2*np.pi*x[:,1])\r\nu += np.random.normal(0.0,0.1,100)\r\n\r\n# interpolation points\r\na = np.linspace(0,1,100)\r\nx1itp,x2itp = np.meshgrid(a,a)\r\nxitp = np.array([x1itp.ravel(),x2itp.ravel()]).T\r\n\r\n# form interpolant\r\nI = RBFInterpolant(x,u,penalty=0.001)\r\n\r\n# evaluate the interpolant\r\nuitp = I(xitp)\r\n\r\n# evaluate the x derivative of the interpolant\r\ndxitp = I(xitp,diff=(1,0))\r\n```\r\nIn the below figure we compare the smoothed interpolant and its \r\nderivative the the true underlying signal.\r\n\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/interpolate/figures/interp2d.png \"interp2d\")\r\n\r\n\r\n### Solving PDEs: Spectral Method\r\nWe can numerically solve PDEs over an arbitrary N-dimensional domain \r\nwith RBFs.  Unlike finite element methods or traditional finite \r\ndifference methods which require a mesh (nodes with known \r\nconnectivity), the RBF method just needs to know the nodes. This makes \r\nit easier to discretize a complicated domain and gives the user more \r\ncontrol over how that discretization is done.\r\n\r\n#### Node generation\r\nThe `rbf.nodes` module provides a function for node generation over an \r\narbitary 1, 2, or 3 dimensional closed domain and also allows for \r\nvariable node density.  Throughout this package domains are defined \r\nusing simplicial complexes, which are a collection of simplices \r\n(points, line segments, and triangles).  A simplicial complex is \r\ndefined with two arrays, one specificing the locations of vertices and \r\nthe other specifying the vertex indices which make up each simplex.  \r\nFor example a unit square can be described as\r\n```python\r\nvert = [[0.0,0.0],\r\n        [1.0,0.0],\r\n        [1.0,1.0]\r\n        [0.0,1.0]]\r\nsmp = [[0,1],\r\n       [1,2],\r\n       [2,3],\r\n       [3,0]]\r\n```             \r\nwhere each row in `smp` defines the vertices in a simplex making up the \r\nunit square. The vertices and simplices for some simple domains can be \r\ngenerated from the functions in `rbf.domain`.\r\n\r\nWe now generate 1000 nodes which are quasi-uniformly spaced within the \r\nunit square. This is done with a minimum energy algorithm. See \r\n`rbf.nodes.menodes` for a detailed description of the arguments and \r\nthe algorithm.\r\n```python\r\nfrom rbf.nodes import menodes\r\n\r\n# number of nodes\r\nN = 1000\r\n\r\n# generate nodes. *nodes* is a (N,2) array and *smpid* is a (N,) \r\n# identifying the simplex, if any, that each node is attached to\r\nnodes,smpid = menodes(N,vert,smp)\r\n\r\nboundary, = np.nonzero(smpid>=0)\r\ninterior, = np.nonzero(smpid==-1)\r\n```\r\nplotting `interior` nodes as black and `boundary` nodes as blue we get \r\nthis figure\r\n\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/nodes/figures/square.png \"square\")\r\n\r\nIn this next example, we create a more complicated domain and have a \r\nnode density that corresponds with the image `Lenna.png` (located in \r\n`rbf/demo`)\r\n```python\r\nfrom PIL import Image\r\n\r\n# define the domain\r\nt = np.linspace(0,2*np.pi,201)\r\nt = t[:-1]\r\nradius = 0.45*(0.1*np.sin(10*t) + 1.0)\r\nvert = np.array([0.5+radius*np.cos(t),0.5+radius*np.sin(t)]).T\r\nsmp = np.array([np.arange(200),np.roll(np.arange(200),-1)]).T\r\n                 \r\nN = 30000\r\n\r\n# make gray scale image\r\nimg = Image.open('Lenna.png')\r\nimga = np.array(img,dtype=float)/256.0\r\ngray = np.linalg.norm(imga,axis=-1)\r\n# normalize so that the max value is 1\r\ngray = gray/gray.max()\r\n\r\n# define the node density function\r\ndef rho(p):\r\n  # x and y are mapped to integers between 0 and 512\r\n  p = p*512\r\n  p = np.array(p,dtype=int)\r\n  return 1.0001 - gray[511-p[:,1],p[:,0]]\r\n\r\n\r\nnodes,smpid = menodes(N,vert,smp,rho=rho)\r\ninterior, = np.nonzero(smpid==-1)\r\nboundary, = np.nonzero(smpid>=0)\r\n```\r\nagain plotting the `interior` nodes as black and `boundary` nodes as \r\nblue\r\n\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/nodes/figures/lenna.png \"lenna\")\r\n\r\n#### Laplace's equation on a circle\r\nHere we are solving Laplace's equation over a unit circle, where the \r\nboundaries are fixed at zero and there is an applied forcing term. The \r\nsolution to this problem is (1-r)\\*sin(x)\\*cos(y). The forcing \r\nterm needed to produce this solution is defined below. This \r\ndemonstration can also be found in `demo/pde/spectral/2d/laplacian.py`.\r\n```python\r\nimport rbf.domain\r\n\r\ndef forcing(x,y):\r\n  return ((2*x**2*np.sin(x)*np.cos(y) - \r\n           2*x*np.cos(x)*np.cos(y) + \r\n           2*y**2*np.sin(x)*np.cos(y) + \r\n           2*y*np.sin(x)*np.sin(y) - \r\n           2*np.sqrt(x**2 + y**2)*np.sin(x)*np.cos(y) - \r\n           np.sin(x)*np.cos(y))/np.sqrt(x**2 + y**2))\r\n\r\n# total number of nodes\r\nN = 100\r\n\r\n# define a circular domain\r\nvert,smp = rbf.domain.circle()\r\n\r\nnodes,smpid = menodes(N,vert,smp)\r\nboundary, = (smpid>=0).nonzero()\r\ninterior, = (smpid==-1).nonzero()\r\n\r\n# create the left-hand-side matrix which is the Laplacian of the basis \r\n# function for interior nodes and the undifferentiated basis functions \r\n# for the boundary nodes\r\nA = np.zeros((N,N))\r\nA[interior]  = phs3(nodes[interior],nodes,diff=[2,0]) \r\nA[interior] += phs3(nodes[interior],nodes,diff=[0,2]) \r\nA[boundary]  = phs3(nodes[boundary],nodes,diff=[0,0])\r\n\r\n# create the right-hand-side vector, consisting of the forcing term \r\n# for the interior nodes and zeros for the boundary nodes\r\nd = np.zeros(N)\r\nd[interior] = forcing(nodes[interior,0],nodes[interior,1]) \r\n\r\n# find the RBF coefficients that solve the PDE\r\ncoeff = np.linalg.solve(A,d)\r\n```\r\nNow that we have the coefficients for the basis functions we can \r\nevaluate the interpolant and view the solution. \r\n\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/pde/spectral/2d/figures/demo_spectral_laplacian.png \"demo_spectral_laplacian\")\r\n\r\n\r\n### Solving PDEs: RBF-FD Method\r\nThe radial basis function generated finite difference (RBF-FD) method \r\nis a relatively new method for solving PDEs.  The RBF-FD method allows \r\none to approximate a derivative as a weighted sum of function \r\nrealizations at N neighboring locations, where the locations can be \r\nrandomly distributed.  Once the weights have been computed, the method \r\nis effectively identical to solving a PDE with a traditional finite \r\ndifference method.  This package offers two functions for computing \r\nthe RBF-FD weights, `rbf.fd.weights` and `rbf.fd.weight_matrix`. The \r\nlatter function allows the user to solve a PDE with almost the exact \r\nsame procedure as for the spectral RBF method (see \r\n`rbf/demo/pde/fd/2d/laplacian.py`).\r\n\r\nFor the function `rbf.fd.weight_matrix`, the stencil generation is \r\ndone under the hood. By default the stencils are just a collection of \r\nnearest neighbors which are efficiently found with \r\n`scipy.spatial.cKDTree`. However, a nearest neighbor stencil may not \r\nbe appropriate for some problems.  For example you may have a domain \r\nwith edges that *nearly* touch and you do not want the PDE to be \r\nenforced across that boundary. The function \r\n`rbf.stencil.stencil_network` creates nearest neighbor stencils but it \r\ndoes not allow stencils to reach across boundaries. This is \r\neffectively done by redefining the distance norm so that if a line \r\nsegment connecting two points intersects a boundary then they are \r\ninfinitely far away.  This function then makes it possible to solve \r\nproblems like this\r\n\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/pde/fd/2d/figures/annulus.png \"demo_fd_annulus\")\r\n\r\nThe above plot is showing the solution to Laplace's equation on a slit \r\nannulus. The edges are free surfaces except for the top and bottom of \r\nthe slit, which are fixed at 1 and -1.  The code which generated the \r\nabove script can be found in `rbf/demo/pde/fd/2d/annulus.py`.\r\n\r\nRBFs seem to have a hard time handling free surface boundary \r\nconditions. In order to get a stable solution it is often necessary to \r\nadd ghost nodes. Ghost nodes are additional nodes placed outside the \r\nboundary. Rather than enforcing the PDE at the ghost nodes, the added \r\nrows in the stiffness matrix are used to enforce the PDE at the \r\nboundary nodes.  A ghost node demonstration can be found in \r\n`rbf/demo/pde/fd/2d/ghosts.py`. The below figure shows the solution to \r\nthe same PDE as above but with the addition of ghost nodes\r\n\r\n![alt text](https://github.com/treverhines/RBF/blob/master/demo/pde/fd/2d/figures/ghosts.png \"demo_fd_annulus\")\r\n\r\n\r\n### To Do\r\nThis package contains more features but they have not yet been \r\nincluded in this help documentation. They include\r\n* generation of RBF-FD stencils (module: rbf.stencil)\r\n* generation of RBF-FD weights (module: rbf.fd)\r\n* computational geometry (module: rbf.geometry)\r\n* generation of halton sequences (module: rbf.halton)\r\n* Monte-Carlo integration (module: rbf.integrate)\r\n* generation of B-spline basis functions (module: rbf.bspline) \r\n* Removing high frequency noise in LARGE, scattered, multidimensional \r\n  data sets (My latest project!, module: rbf.filter)\r\n\r\nSee the documentation within the modules for help on using these \r\nfeatures\r\n\r\n### Acknowledgements\r\nThis package has been largely inspired by the book \"A Primer on \r\nRadial Basis Functions with Applications to the Geosciences\" by \r\nBengt Fornberg and Natasha Flyer.  \r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}